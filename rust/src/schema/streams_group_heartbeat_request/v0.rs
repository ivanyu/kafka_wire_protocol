// This file was generated. Do not edit.

use std::io::{Read, Result, Write};

use serde::{Deserialize, Serialize};
#[cfg(test)] use proptest_derive::Arbitrary;

use crate::arrays::{read_array, read_nullable_array, write_array, write_nullable_array};
use crate::markers::{ApiMessage, Request};
use crate::readable_writable::{Readable, Writable};
use crate::tagged_fields::{RawTaggedField, read_tagged_fields, write_tagged_fields};
#[cfg(test)] use crate::test_utils::proptest_strategies;

/// StreamsGroupHeartbeatRequest, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct StreamsGroupHeartbeatRequest {
    /// The group identifier.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub group_id: String,
    /// The member ID generated by the streams consumer. The member ID must be kept during the entire lifetime of the streams consumer process.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub member_id: String,
    /// The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.
    pub member_epoch: i32,
    /// The current endpoint epoch of this client, represents the latest endpoint epoch this client received
    pub endpoint_information_epoch: i32,
    /// null if not provided or if it didn't change since the last heartbeat; the instance ID for static membership otherwise.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_string()"))]
    pub instance_id: Option<String>,
    /// null if not provided or if it didn't change since the last heartbeat; the rack ID of the member otherwise.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_string()"))]
    pub rack_id: Option<String>,
    /// -1 if it didn't change since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its tasks otherwise.
    pub rebalance_timeout_ms: i32,
    /// The topology metadata of the streams application. Used to initialize the topology of the group and to check if the topology corresponds to the topology initialized for the group. Only sent when memberEpoch = 0, must be non-empty. Null otherwise.
    pub topology: Option<Topology>,
    /// Currently owned active tasks for this client. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub active_tasks: Option<Vec<TaskIds>>,
    /// Currently owned standby tasks for this client. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub standby_tasks: Option<Vec<TaskIds>>,
    /// Currently owned warm-up tasks for this client. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub warmup_tasks: Option<Vec<TaskIds>>,
    /// Identity of the streams instance that may have multiple consumers. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_string()"))]
    pub process_id: Option<String>,
    /// User-defined endpoint for Interactive Queries. Null if unchanged since last heartbeat, or if not defined on the client.
    pub user_endpoint: Option<Endpoint>,
    /// Used for rack-aware assignment algorithm. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub client_tags: Option<Vec<KeyValue>>,
    /// Cumulative changelog offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub task_offsets: Option<Vec<TaskOffset>>,
    /// Cumulative changelog end-offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::optional_vec()"))]
    pub task_end_offsets: Option<Vec<TaskOffset>>,
    /// Whether all Streams clients in the group should shut down.
    pub shutdown_application: bool,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl ApiMessage for StreamsGroupHeartbeatRequest {
    fn api_key(&self) -> i16 {
        88
    }
    
    fn version(&self) -> i16 {
        0
    }
}

impl Request for StreamsGroupHeartbeatRequest { }

impl Default for StreamsGroupHeartbeatRequest {
    fn default() -> Self {
        StreamsGroupHeartbeatRequest {
            group_id: String::from(""),
            member_id: String::from(""),
            member_epoch: 0_i32,
            endpoint_information_epoch: 0_i32,
            instance_id: None,
            rack_id: None,
            rebalance_timeout_ms: -1_i32,
            topology: None,
            active_tasks: None,
            standby_tasks: None,
            warmup_tasks: None,
            process_id: None,
            user_endpoint: None,
            client_tags: None,
            task_offsets: None,
            task_end_offsets: None,
            shutdown_application: false,
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl StreamsGroupHeartbeatRequest {
    pub fn new<S1: AsRef<str>, S2: AsRef<str>, S3: AsRef<str>, S4: AsRef<str>, S5: AsRef<str>>(group_id: S1, member_id: S2, member_epoch: i32, endpoint_information_epoch: i32, instance_id: Option<S3>, rack_id: Option<S4>, rebalance_timeout_ms: i32, topology: Option<Topology>, active_tasks: Option<Vec<TaskIds>>, standby_tasks: Option<Vec<TaskIds>>, warmup_tasks: Option<Vec<TaskIds>>, process_id: Option<S5>, user_endpoint: Option<Endpoint>, client_tags: Option<Vec<KeyValue>>, task_offsets: Option<Vec<TaskOffset>>, task_end_offsets: Option<Vec<TaskOffset>>, shutdown_application: bool) -> Self {
        Self {
            group_id: group_id.as_ref().to_string(),
            member_id: member_id.as_ref().to_string(),
            member_epoch,
            endpoint_information_epoch,
            instance_id: instance_id.map(|s| s.as_ref().to_string()),
            rack_id: rack_id.map(|s| s.as_ref().to_string()),
            rebalance_timeout_ms,
            topology,
            active_tasks,
            standby_tasks,
            warmup_tasks,
            process_id: process_id.map(|s| s.as_ref().to_string()),
            user_endpoint,
            client_tags,
            task_offsets,
            task_end_offsets,
            shutdown_application,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_streams_group_heartbeat_request_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = StreamsGroupHeartbeatRequest::new(
            String::from(""),
            String::from(""),
            0_i32,
            0_i32,
            None::<String>,
            None::<String>,
            -1_i32,
            None::<Topology>,
            None::<Vec::<TaskIds>>,
            None::<Vec::<TaskIds>>,
            None::<Vec::<TaskIds>>,
            None::<String>,
            None::<Endpoint>,
            None::<Vec::<KeyValue>>,
            None::<Vec::<TaskOffset>>,
            None::<Vec::<TaskOffset>>,
            false,
        );
        assert_eq!(d, StreamsGroupHeartbeatRequest::default());
    }
}

impl Readable for StreamsGroupHeartbeatRequest {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let group_id = String::read_ext(input, "group_id", true)?;
        let member_id = String::read_ext(input, "member_id", true)?;
        let member_epoch = i32::read(input)?;
        let endpoint_information_epoch = i32::read(input)?;
        let instance_id = Option::<String>::read_ext(input, "instance_id", true)?;
        let rack_id = Option::<String>::read_ext(input, "rack_id", true)?;
        let rebalance_timeout_ms = i32::read(input)?;
        let topology = (if i8::read(input)? < 0 { Ok(None) } else { Topology::read(input).map(Some) })?;
        let active_tasks = read_nullable_array::<TaskIds>(input, "active_tasks", true)?;
        let standby_tasks = read_nullable_array::<TaskIds>(input, "standby_tasks", true)?;
        let warmup_tasks = read_nullable_array::<TaskIds>(input, "warmup_tasks", true)?;
        let process_id = Option::<String>::read_ext(input, "process_id", true)?;
        let user_endpoint = (if i8::read(input)? < 0 { Ok(None) } else { Endpoint::read(input).map(Some) })?;
        let client_tags = read_nullable_array::<KeyValue>(input, "client_tags", true)?;
        let task_offsets = read_nullable_array::<TaskOffset>(input, "task_offsets", true)?;
        let task_end_offsets = read_nullable_array::<TaskOffset>(input, "task_end_offsets", true)?;
        let shutdown_application = bool::read(input)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(StreamsGroupHeartbeatRequest {
            group_id, member_id, member_epoch, endpoint_information_epoch, instance_id, rack_id, rebalance_timeout_ms, topology, active_tasks, standby_tasks, warmup_tasks, process_id, user_endpoint, client_tags, task_offsets, task_end_offsets, shutdown_application, _unknown_tagged_fields
        })
    }
}

impl Writable for StreamsGroupHeartbeatRequest {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.group_id.write_ext(output, "self.group_id", true)?;
        self.member_id.write_ext(output, "self.member_id", true)?;
        self.member_epoch.write(output)?;
        self.endpoint_information_epoch.write(output)?;
        self.instance_id.write_ext(output, "self.instance_id", true)?;
        self.rack_id.write_ext(output, "self.rack_id", true)?;
        self.rebalance_timeout_ms.write(output)?;
        (if let Some(v) = &self.topology { 1_i8.write(output)?; v.write(output) } else { (-1_i8).write(output) })?;
        write_nullable_array(output, "self.active_tasks", self.active_tasks.as_deref(), true)?;
        write_nullable_array(output, "self.standby_tasks", self.standby_tasks.as_deref(), true)?;
        write_nullable_array(output, "self.warmup_tasks", self.warmup_tasks.as_deref(), true)?;
        self.process_id.write_ext(output, "self.process_id", true)?;
        (if let Some(v) = &self.user_endpoint { 1_i8.write(output)?; v.write(output) } else { (-1_i8).write(output) })?;
        write_nullable_array(output, "self.client_tags", self.client_tags.as_deref(), true)?;
        write_nullable_array(output, "self.task_offsets", self.task_offsets.as_deref(), true)?;
        write_nullable_array(output, "self.task_end_offsets", self.task_end_offsets.as_deref(), true)?;
        self.shutdown_application.write(output)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// Topology, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Topology {
    /// The epoch of the topology. Used to check if the topology corresponds to the topology initialized on the brokers.
    pub epoch: i32,
    /// The sub-topologies of the streams application.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub subtopologies: Vec<Subtopology>,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for Topology {
    fn default() -> Self {
        Topology {
            epoch: 0_i32,
            subtopologies: Vec::<Subtopology>::new(),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl Topology {
    pub fn new(epoch: i32, subtopologies: Vec<Subtopology>) -> Self {
        Self {
            epoch,
            subtopologies,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_topology_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = Topology::new(
            0_i32,
            Vec::<Subtopology>::new(),
        );
        assert_eq!(d, Topology::default());
    }
}

impl Readable for Topology {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let epoch = i32::read(input)?;
        let subtopologies = read_array::<Subtopology>(input, "subtopologies", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(Topology {
            epoch, subtopologies, _unknown_tagged_fields
        })
    }
}

impl Writable for Topology {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.epoch.write(output)?;
        write_array(output, "self.subtopologies", &self.subtopologies, true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// Subtopology, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Subtopology {
    /// String to uniquely identify the subtopology. Deterministically generated from the topology
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub subtopology_id: String,
    /// The topics the topology reads from.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub source_topics: Vec<String>,
    /// The regular expressions identifying topics the subtopology reads from.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub source_topic_regex: Vec<String>,
    /// The set of state changelog topics associated with this subtopology. Created automatically.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub state_changelog_topics: Vec<TopicInfo>,
    /// The repartition topics the subtopology writes to.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub repartition_sink_topics: Vec<String>,
    /// The set of source topics that are internally created repartition topics. Created automatically.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub repartition_source_topics: Vec<TopicInfo>,
    /// A subset of source topics that must be copartitioned.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub copartition_groups: Vec<CopartitionGroup>,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for Subtopology {
    fn default() -> Self {
        Subtopology {
            subtopology_id: String::from(""),
            source_topics: Vec::<String>::new(),
            source_topic_regex: Vec::<String>::new(),
            state_changelog_topics: Vec::<TopicInfo>::new(),
            repartition_sink_topics: Vec::<String>::new(),
            repartition_source_topics: Vec::<TopicInfo>::new(),
            copartition_groups: Vec::<CopartitionGroup>::new(),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl Subtopology {
    pub fn new<S1: AsRef<str>>(subtopology_id: S1, source_topics: Vec<String>, source_topic_regex: Vec<String>, state_changelog_topics: Vec<TopicInfo>, repartition_sink_topics: Vec<String>, repartition_source_topics: Vec<TopicInfo>, copartition_groups: Vec<CopartitionGroup>) -> Self {
        Self {
            subtopology_id: subtopology_id.as_ref().to_string(),
            source_topics,
            source_topic_regex,
            state_changelog_topics,
            repartition_sink_topics,
            repartition_source_topics,
            copartition_groups,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_subtopology_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = Subtopology::new(
            String::from(""),
            Vec::<String>::new(),
            Vec::<String>::new(),
            Vec::<TopicInfo>::new(),
            Vec::<String>::new(),
            Vec::<TopicInfo>::new(),
            Vec::<CopartitionGroup>::new(),
        );
        assert_eq!(d, Subtopology::default());
    }
}

impl Readable for Subtopology {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let subtopology_id = String::read_ext(input, "subtopology_id", true)?;
        let source_topics = read_array::<String>(input, "source_topics", true)?;
        let source_topic_regex = read_array::<String>(input, "source_topic_regex", true)?;
        let state_changelog_topics = read_array::<TopicInfo>(input, "state_changelog_topics", true)?;
        let repartition_sink_topics = read_array::<String>(input, "repartition_sink_topics", true)?;
        let repartition_source_topics = read_array::<TopicInfo>(input, "repartition_source_topics", true)?;
        let copartition_groups = read_array::<CopartitionGroup>(input, "copartition_groups", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(Subtopology {
            subtopology_id, source_topics, source_topic_regex, state_changelog_topics, repartition_sink_topics, repartition_source_topics, copartition_groups, _unknown_tagged_fields
        })
    }
}

impl Writable for Subtopology {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.subtopology_id.write_ext(output, "self.subtopology_id", true)?;
        write_array(output, "self.source_topics", &self.source_topics, true)?;
        write_array(output, "self.source_topic_regex", &self.source_topic_regex, true)?;
        write_array(output, "self.state_changelog_topics", &self.state_changelog_topics, true)?;
        write_array(output, "self.repartition_sink_topics", &self.repartition_sink_topics, true)?;
        write_array(output, "self.repartition_source_topics", &self.repartition_source_topics, true)?;
        write_array(output, "self.copartition_groups", &self.copartition_groups, true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// CopartitionGroup, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct CopartitionGroup {
    /// The topics the topology reads from. Index into the array on the subtopology level.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub source_topics: Vec<i16>,
    /// Regular expressions identifying topics the subtopology reads from. Index into the array on the subtopology level.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub source_topic_regex: Vec<i16>,
    /// The set of source topics that are internally created repartition topics. Index into the array on the subtopology level.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub repartition_source_topics: Vec<i16>,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for CopartitionGroup {
    fn default() -> Self {
        CopartitionGroup {
            source_topics: Vec::<i16>::new(),
            source_topic_regex: Vec::<i16>::new(),
            repartition_source_topics: Vec::<i16>::new(),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl CopartitionGroup {
    pub fn new(source_topics: Vec<i16>, source_topic_regex: Vec<i16>, repartition_source_topics: Vec<i16>) -> Self {
        Self {
            source_topics,
            source_topic_regex,
            repartition_source_topics,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_copartition_group_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = CopartitionGroup::new(
            Vec::<i16>::new(),
            Vec::<i16>::new(),
            Vec::<i16>::new(),
        );
        assert_eq!(d, CopartitionGroup::default());
    }
}

impl Readable for CopartitionGroup {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let source_topics = read_array::<i16>(input, "source_topics", true)?;
        let source_topic_regex = read_array::<i16>(input, "source_topic_regex", true)?;
        let repartition_source_topics = read_array::<i16>(input, "repartition_source_topics", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(CopartitionGroup {
            source_topics, source_topic_regex, repartition_source_topics, _unknown_tagged_fields
        })
    }
}

impl Writable for CopartitionGroup {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        write_array(output, "self.source_topics", &self.source_topics, true)?;
        write_array(output, "self.source_topic_regex", &self.source_topic_regex, true)?;
        write_array(output, "self.repartition_source_topics", &self.repartition_source_topics, true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// Endpoint, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Endpoint {
    /// host of the endpoint
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub host: String,
    /// port of the endpoint
    pub port: u16,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for Endpoint {
    fn default() -> Self {
        Endpoint {
            host: String::from(""),
            port: 0_u16,
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl Endpoint {
    pub fn new<S1: AsRef<str>>(host: S1, port: u16) -> Self {
        Self {
            host: host.as_ref().to_string(),
            port,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_endpoint_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = Endpoint::new(
            String::from(""),
            0_u16,
        );
        assert_eq!(d, Endpoint::default());
    }
}

impl Readable for Endpoint {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let host = String::read_ext(input, "host", true)?;
        let port = u16::read(input)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(Endpoint {
            host, port, _unknown_tagged_fields
        })
    }
}

impl Writable for Endpoint {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.host.write_ext(output, "self.host", true)?;
        self.port.write(output)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// KeyValue, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct KeyValue {
    /// key of the config
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub key: String,
    /// value of the config
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub value: String,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for KeyValue {
    fn default() -> Self {
        KeyValue {
            key: String::from(""),
            value: String::from(""),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl KeyValue {
    pub fn new<S1: AsRef<str>, S2: AsRef<str>>(key: S1, value: S2) -> Self {
        Self {
            key: key.as_ref().to_string(),
            value: value.as_ref().to_string(),
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_key_value_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = KeyValue::new(
            String::from(""),
            String::from(""),
        );
        assert_eq!(d, KeyValue::default());
    }
}

impl Readable for KeyValue {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let key = String::read_ext(input, "key", true)?;
        let value = String::read_ext(input, "value", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(KeyValue {
            key, value, _unknown_tagged_fields
        })
    }
}

impl Writable for KeyValue {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.key.write_ext(output, "self.key", true)?;
        self.value.write_ext(output, "self.value", true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// TaskIds, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct TaskIds {
    /// The subtopology identifier.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub subtopology_id: String,
    /// The partitions of the input topics processed by this member.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub partitions: Vec<i32>,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for TaskIds {
    fn default() -> Self {
        TaskIds {
            subtopology_id: String::from(""),
            partitions: Vec::<i32>::new(),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl TaskIds {
    pub fn new<S1: AsRef<str>>(subtopology_id: S1, partitions: Vec<i32>) -> Self {
        Self {
            subtopology_id: subtopology_id.as_ref().to_string(),
            partitions,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_task_ids_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = TaskIds::new(
            String::from(""),
            Vec::<i32>::new(),
        );
        assert_eq!(d, TaskIds::default());
    }
}

impl Readable for TaskIds {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let subtopology_id = String::read_ext(input, "subtopology_id", true)?;
        let partitions = read_array::<i32>(input, "partitions", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(TaskIds {
            subtopology_id, partitions, _unknown_tagged_fields
        })
    }
}

impl Writable for TaskIds {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.subtopology_id.write_ext(output, "self.subtopology_id", true)?;
        write_array(output, "self.partitions", &self.partitions, true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// TaskOffset, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct TaskOffset {
    /// The subtopology identifier.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub subtopology_id: String,
    /// The partition.
    pub partition: i32,
    /// The offset.
    pub offset: i64,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for TaskOffset {
    fn default() -> Self {
        TaskOffset {
            subtopology_id: String::from(""),
            partition: 0_i32,
            offset: 0_i64,
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl TaskOffset {
    pub fn new<S1: AsRef<str>>(subtopology_id: S1, partition: i32, offset: i64) -> Self {
        Self {
            subtopology_id: subtopology_id.as_ref().to_string(),
            partition,
            offset,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_task_offset_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = TaskOffset::new(
            String::from(""),
            0_i32,
            0_i64,
        );
        assert_eq!(d, TaskOffset::default());
    }
}

impl Readable for TaskOffset {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let subtopology_id = String::read_ext(input, "subtopology_id", true)?;
        let partition = i32::read(input)?;
        let offset = i64::read(input)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(TaskOffset {
            subtopology_id, partition, offset, _unknown_tagged_fields
        })
    }
}

impl Writable for TaskOffset {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.subtopology_id.write_ext(output, "self.subtopology_id", true)?;
        self.partition.write(output)?;
        self.offset.write(output)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

/// TopicInfo, version 0.
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct TopicInfo {
    /// The name of the topic.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::string()"))]
    pub name: String,
    /// The number of partitions in the topic. Can be 0 if no specific number of partitions is enforced. Always 0 for changelog topics.
    pub partitions: i32,
    /// The replication factor of the topic. Can be 0 if the default replication factor should be used.
    pub replication_factor: i16,
    /// Topic-level configurations as key-value pairs.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::vec()"))]
    pub topic_configs: Vec<KeyValue>,
    /// Unknown tagged fields.
    #[cfg_attr(test, proptest(strategy = "proptest_strategies::unknown_tagged_fields()"))]
    pub _unknown_tagged_fields: Vec<RawTaggedField>,
}

impl Default for TopicInfo {
    fn default() -> Self {
        TopicInfo {
            name: String::from(""),
            partitions: 0_i32,
            replication_factor: 0_i16,
            topic_configs: Vec::<KeyValue>::new(),
            _unknown_tagged_fields: Vec::new(),
        }
    }
}

impl TopicInfo {
    pub fn new<S1: AsRef<str>>(name: S1, partitions: i32, replication_factor: i16, topic_configs: Vec<KeyValue>) -> Self {
        Self {
            name: name.as_ref().to_string(),
            partitions,
            replication_factor,
            topic_configs,
            _unknown_tagged_fields: vec![],
        }
    }
}

#[cfg(test)]
mod tests_topic_info_new_and_default {
    use super::*;
    
    #[test]
    fn test() {
        let d = TopicInfo::new(
            String::from(""),
            0_i32,
            0_i16,
            Vec::<KeyValue>::new(),
        );
        assert_eq!(d, TopicInfo::default());
    }
}

impl Readable for TopicInfo {
    fn read(#[allow(unused)] input: &mut impl Read) -> Result<Self> {
        let name = String::read_ext(input, "name", true)?;
        let partitions = i32::read(input)?;
        let replication_factor = i16::read(input)?;
        let topic_configs = read_array::<KeyValue>(input, "topic_configs", true)?;
        let tagged_fields_callback = |tag: i32, _: &[u8]| {
            match tag {
                _ => Ok(false)
            }
        };
        let _unknown_tagged_fields = read_tagged_fields(input, tagged_fields_callback)?;
        Ok(TopicInfo {
            name, partitions, replication_factor, topic_configs, _unknown_tagged_fields
        })
    }
}

impl Writable for TopicInfo {
    fn write(&self, #[allow(unused)] output: &mut impl Write) -> Result<()> {
        self.name.write_ext(output, "self.name", true)?;
        self.partitions.write(output)?;
        self.replication_factor.write(output)?;
        write_array(output, "self.topic_configs", &self.topic_configs, true)?;
        write_tagged_fields(output, &[], &self._unknown_tagged_fields)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    
    #[test]
    fn test_java_default() {
        crate::test_utils::test_java_default::<StreamsGroupHeartbeatRequest>("StreamsGroupHeartbeatRequest", 0);
    }
    
    proptest! {
        #[test]
        fn test_serde(data: StreamsGroupHeartbeatRequest) {
            crate::test_utils::test_serde(&data)?;
        }
    }
    
    proptest! {
        #[test]
        fn test_java_arbitrary(data: StreamsGroupHeartbeatRequest) {
            crate::test_utils::test_java_arbitrary(&data, "StreamsGroupHeartbeatRequest", 0);
        }
    }
}
